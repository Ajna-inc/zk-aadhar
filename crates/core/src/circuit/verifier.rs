//! Proof verification for Aadhar ZK circuits

use p3_field::PrimeField32;
use p3_mersenne_31::Mersenne31;
use p3_uni_stark::verify;

use crate::circuit::{
    commitment::CommitmentAir,
    config::create_config,
};
use crate::error::{AadharError, Result};

/// Verify a ZK proof of Aadhar commitment
///
/// This verifies that a proof is valid for a given commitment value,
/// without learning anything about the underlying Aadhar data.
///
/// # Arguments
/// * `proof_bytes` - Serialized proof generated by `prove_aadhar_commitment`
/// * `expected_commitment` - The commitment value that was proven
///
/// # Returns
/// `Ok(true)` if proof is valid, `Err` if invalid or malformed
///
/// # Example
/// ```no_run
/// use aadhar_core::circuit::{prove_aadhar_commitment, verify_aadhar_commitment};
/// use aadhar_core::circuit::commitment::compute_aadhar_commitment;
/// use aadhar_core::xml::parse_aadhar_zip;
///
/// let aadhar_data = parse_aadhar_zip("aadhar.zip", "1234")?;
///
/// // Prover generates proof
/// let proof = prove_aadhar_commitment(&aadhar_data)?;
/// let commitment = compute_aadhar_commitment(&aadhar_data);
///
/// // Verifier verifies proof (doesn't need access to Aadhar data!)
/// let is_valid = verify_aadhar_commitment(&proof, commitment)?;
/// assert!(is_valid);
/// # Ok::<(), aadhar_core::error::AadharError>(())
/// ```
pub fn verify_aadhar_commitment(
    proof_bytes: &[u8],
    expected_commitment: Mersenne31,
) -> Result<bool> {
    log::info!("Verifying ZK proof");
    log::debug!("Expected commitment: {}", expected_commitment.as_canonical_u32());
    log::debug!("Proof size: {} bytes", proof_bytes.len());

    // Step 1: Deserialize the proof
    let proof = bincode::deserialize(proof_bytes)
        .map_err(|e| AadharError::Other(format!("Failed to deserialize proof: {}", e)))?;

    log::info!("✓ Proof deserialized");

    // Step 2: Create AIR with the expected commitment (public input)
    let air = CommitmentAir {
        expected_commitment,
    };

    // Step 3: Setup Plonky3 configuration (must match prover's config)
    let config = create_config();

    // Step 4: Verify the proof
    log::info!("Verifying proof...");
    let start = std::time::Instant::now();

    let result = verify(&config, &air, &proof, &vec![]);

    let duration = start.elapsed();

    match result {
        Ok(()) => {
            log::info!("✓ Proof VALID (verified in {:.2?})", duration);
            Ok(true)
        }
        Err(e) => {
            log::warn!("✗ Proof INVALID: {:?}", e);
            Err(AadharError::Other(format!("Proof verification failed: {:?}", e)))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::circuit::{compute_aadhar_commitment, prove_aadhar_commitment};
    use crate::xml::{AddressInfo, PersonalInfo, Signature, AadharData};

    fn create_test_aadhar() -> AadharData {
        AadharData {
            reference_id: "123456789".to_string(),
            poi: PersonalInfo {
                name: "Test User".to_string(),
                dob: "01-01-2000".to_string(),
                gender: "M".to_string(),
                dob_parsed: None,
            },
            poa: AddressInfo {
                care_of: Some("Parent Name".to_string()),
                house: Some("123".to_string()),
                street: Some("Main St".to_string()),
                landmark: None,
                locality: Some("Locality".to_string()),
                vtc: Some("City".to_string()),
                subdist: None,
                district: Some("District".to_string()),
                state: Some("State".to_string()),
                pincode: Some("123456".to_string()),
                post_office: None,
                country: Some("India".to_string()),
            },
            photo: None,
            signature: Signature {
                value: "test_signature".to_string(),
                algorithm: None,
                verified: true,
            },
            mobile_hash: None,
            email_hash: None,
        }
    }

    #[test]
    fn test_verify_valid_proof() {
        env_logger::try_init().ok();

        let aadhar = create_test_aadhar();

        // Generate proof
        let proof = prove_aadhar_commitment(&aadhar)
            .expect("Failed to generate proof");

        // Compute commitment
        let commitment = compute_aadhar_commitment(&aadhar);

        // Verify proof
        let result = verify_aadhar_commitment(&proof, commitment);

        assert!(result.is_ok(), "Verification failed: {:?}", result.err());
        assert_eq!(result.unwrap(), true);

        println!("✓ Proof verified successfully");
    }

    #[test]
    fn test_verify_wrong_commitment() {
        env_logger::try_init().ok();

        let aadhar = create_test_aadhar();

        // Generate proof
        let proof = prove_aadhar_commitment(&aadhar)
            .expect("Failed to generate proof");

        // Use WRONG commitment
        use p3_field::PrimeCharacteristicRing;
        let wrong_commitment = Mersenne31::from_u32(99999);

        // Verification should fail
        let result = verify_aadhar_commitment(&proof, wrong_commitment);

        assert!(result.is_err(), "Verification should have failed with wrong commitment");

        println!("✓ Correctly rejected proof with wrong commitment");
    }
}
